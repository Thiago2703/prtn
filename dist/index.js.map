{"version":3,"sources":["webpack://mail-proton-api/webpack/universalModuleDefinition","webpack://mail-proton-api/./lib/helpers/queryStringStringify.ts","webpack://mail-proton-api/./lib/helpers/randomString.ts","webpack://mail-proton-api/./lib/helpers/rateLimiter.ts","webpack://mail-proton-api/./lib/index.ts","webpack://mail-proton-api/./lib/protonmailClient/events/index.ts","webpack://mail-proton-api/./lib/protonmailClient/index.ts","webpack://mail-proton-api/./lib/protonmailClient/keys/index.ts","webpack://mail-proton-api/./lib/protonmailClient/labels/index.ts","webpack://mail-proton-api/./lib/protonmailClient/labels/types.ts","webpack://mail-proton-api/./lib/protonmailClient/messages/index.ts","webpack://mail-proton-api/./lib/protonmailClient/users/index.ts","webpack://mail-proton-api/./lib/srp/constants.ts","webpack://mail-proton-api/./lib/srp/keys.ts","webpack://mail-proton-api/./lib/srp/passwords.ts","webpack://mail-proton-api/./lib/srp/srp.ts","webpack://mail-proton-api/./lib/srp/utils/bigNumber.ts","webpack://mail-proton-api/./lib/srp/utils/modulusWorkaround.ts","webpack://mail-proton-api/./lib/srp/utils/username.ts","webpack://mail-proton-api/external \"axios\"","webpack://mail-proton-api/external \"bcryptjs\"","webpack://mail-proton-api/external \"bignumber.js\"","webpack://mail-proton-api/external \"create-hash\"","webpack://mail-proton-api/external \"events\"","webpack://mail-proton-api/external \"openpgp\"","webpack://mail-proton-api/external \"randombytes\"","webpack://mail-proton-api/webpack/bootstrap","webpack://mail-proton-api/webpack/startup"],"names":["root","factory","exports","module","define","amd","global","obj","res","key","hasOwnProperty","value","encodedValue","encodeURIComponent","push","join","getRandomString","length","charset","result","i","Math","floor","random","wait","milliseconds","Promise","resolve","setTimeout","lastRequestTime","Date","now","this","client","request","method","url","data","id","ProtonmailClient","EventEmitter","options","super","isloggedIn_","refreshingToken_","accessToken_","refreshToken_","pmUID_","keysInfo_","publicKey","privateKey","passphrase","rateLimiter","RateLimiter","domain","rateLimit","userAgent","users_","UsersRoutes","keys_","KeysRoutes","labels_","LabelsRoutes","messages_","MessagesRoutes","events_","EventsRoutes","axios","createAxiosInstance","v","transformResponse","concat","defaults","headers","window","pmUID","accessToken","Authorization","create","baseURL","withCredentials","config","timeout","error","response","status","refreshToken","loginWithToken","RefreshToken","Uid","emit","loginInformation","authRefresh","AccessToken","passwordInformation","Error","key_id","privateKey_","token_","keys","address","Addresses","forEach","addr","Keys","Primary","Token","PrivateKey","PublicKey","users","User","ID","key_salt","keySalts","KeySalts","salt","KeySalt","computeKeyPassword","password","publicKey_1","readKey","armoredKey","privateKey_1","decryptKey","readPrivateKey","message_1","readMessage","armoredMessage","decrypted_","decrypt","message","decryptionKeys","verificationKeys","Body","decrypted","username","replace","authInfoResponse","authInfo","req","getSrp","Version","Modulus","ServerEphemeral","Username","Salt","loginPassword","authData","ClientProof","clientProof","ClientEphemeral","clientEphemeral","SRPSession","authResponse","auth","expectedServerProof","ServerProof","test","twoFactorEnabled","Enabled","TOTP","otpToken","auth2FA","TwoFactorCode","post","uid","GrantType","RedirectURI","ResponseType","State","UID","args","queryStringStringify","DefaultLabels","LabelType","IDs","labelId","LabelID","Trash","VERIFICATION_STATUS","NOT_SIGNED","SIGNED_AND_VALID","SIGNED_AND_INVALID","SRP_LEN","AUTH_FALLBACK_VERSION","AUTH_VERSION","MAX_VALUE_ITERATIONS","SRP_MODULUS_KEY","BCRYPT_PREFIX","saltBinary","Buffer","from","hash","encodeBase64","slice","generateKeySalt","toString","encodeUtf8","input","unescape","expandHash","promises","arr","update","digest","all","formatHash","modulus","unexpandedHash","hashPassword1","toLowerCase","hashPassword","version","hashPassword3","cleanUsername","prehashed","hashPassword0","ZERO_BN","ONE_BN","TWO_BN","srpHasher","generateClientSecret","len","toBN","buf","alloc","generateParameters","generator","serverEphemeralArray","clientSecret","comparator","isLessThanOrEqualTo","getClientSecret","exponentiatedBy","clientEphemeralArray","fromBN","clientServerHash","scramblingParam","generateProofs","modulusArray","hashedPasswordArray","modulusBn","hashedArray","multiplierBn","serverEphemeral","hashedPassword","modulusMinusOne","minus","multiplierReduced","mod","isGreaterThanOrEqualTo","isEqualTo","getParameters","subtracted","multipliedBy","isLessThan","plus","exponent","modulo","sharedSession","sharedSessionArray","serverModulus","authVersion","getModulusWithoutVerification","undefined","reversed","bn","str","base64Modulus","split","find","l","name","require","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"mail-proton-api\"] = factory();\n\telse\n\t\troot[\"mail-proton-api\"] = factory();\n})(global, function() {\nreturn ","export function queryStringStringify(obj: any) {\n    const res: string[] = [];\n    for (const key in obj) {\n        // eslint-disable-next-line no-prototype-builtins\n        if (obj.hasOwnProperty(key)) {\n            const value = obj[key];\n            if (typeof value === \"undefined\") {\n                continue;\n            }\n\n            let encodedValue = encodeURIComponent(value);\n            if (typeof value === \"boolean\") {\n                encodedValue = value ? \"1\" : \"0\";\n            }\n\n            res.push(`${key}=${encodedValue}`);\n        }\n    }\n\n    return res.join(\"&\");\n}\n","export const getRandomString = (length: number) => {\n    const charset = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    const result = [];\n\n    for (let i = 0; i < length; i++) {\n        result.push(charset[Math.floor(Math.random() * charset.length)]);\n    }\n\n    return result.join(\"\");\n};\n","export async function wait(milliseconds: number) {\n    return new Promise((resolve) => setTimeout(resolve, milliseconds));\n}\n\nexport class RateLimiter {\n    public lastRequestTime = 0;\n\n    public async wait() {\n        while (Date.now() - this.lastRequestTime < 1000) {\n            await wait(100);\n        }\n        this.lastRequestTime = Date.now();\n        return false;\n    }\n}\n","export * from \"./protonmailClient/index\";\nexport * from \"./protonmailClient/auth/types\";\nexport * from \"./protonmailClient/labels/types\";\nexport * from \"./protonmailClient/messages/types\";\nexport * from \"./protonmailClient/users/types\";\n","import { ProtonmailClient } from \"../index\";\nimport { IEventsGetResponse } from \"./types\";\n\nexport class EventsRoutes {\n    private client: ProtonmailClient;\n\n    constructor(client: ProtonmailClient) {\n        this.client = client;\n    }\n\n    public async latest() {\n        const response = await this.client.request<IEventsGetResponse>({\n            method: \"get\",\n            url: \"events/latest\",\n        });\n        return response.data;\n    }\n\n    public async get(id: string) {\n        const response = await this.client.request<IEventsGetResponse>({\n            method: \"get\",\n            url: `events/${id}`,\n        });\n        return response.data;\n    }\n\n}\n","import { decryptKey, readKey, readMessage, decrypt, readPrivateKey } from \"openpgp\";\nimport axios, { AxiosTransformer, AxiosInstance, AxiosRequestConfig, AxiosResponse } from \"axios\";\nimport { RateLimiter, wait } from \"../helpers/rateLimiter\";\n\nimport { IAuthInfoResponse, IAuthRequest, IAuthResponse, ILoginInformation, IAuthRefreshResponse, ITokenLoginInformation, IAuth2FARequest, IAuth2FAResponse } from \"./auth/types\";\nimport { IPasswordInformation } from \"./keys/types\";\nimport { getRandomString } from \"../helpers/randomString\";\nimport { getSrp } from \"../srp/srp\";\nimport { computeKeyPassword } from \"../srp/keys\";\nimport { UsersRoutes } from \"./users/index\";\nimport { LabelsRoutes } from \"./labels/index\";\nimport { MessagesRoutes } from \"./messages/index\";\nimport { EventEmitter } from \"events\";\nimport { IBaseAPIResponse } from \"./types\";\nimport { EventsRoutes } from \"./events\";\nimport { KeysRoutes } from \"./keys\";\nimport { IMessage } from \"./messages/types\";\n\nexport interface IProtonmailClientOptions {\n    domain: string;\n    rateLimit: boolean;\n    userAgent: string;\n}\n\nexport interface IProtonmailKeys {\n    publicKey: string;\n    privateKey: string;\n    passphrase: string;\n}\n\nexport declare interface IProtonmailClient {\n    on(event: \"logout\", listener: () => void): this;\n\n    on(event: string, listener: Function): this;\n}\n\nexport class ProtonmailClient extends EventEmitter {\n    private axios: AxiosInstance;\n    private isloggedIn_: boolean = false;\n    private refreshingToken_: boolean = false;\n    private accessToken_: string = \"\";\n    private refreshToken_: string = \"\";\n    private pmUID_: string = \"\";\n    private keysInfo_: IProtonmailKeys = {\n        publicKey: \"\",\n        privateKey: \"\",\n        passphrase: \"\",\n    }\n    private rateLimiter: RateLimiter = new RateLimiter();\n    private options: IProtonmailClientOptions = {\n        domain: \"mail.protonmail.com\",\n        rateLimit: true,\n        userAgent: \"Mozilla/5.0 (Windows NT 6.1; rv:60.0) Gecko/20100101 Firefox/60.0\",\n    }\n\n    private get pmUID(): string {\n        return this.pmUID_;\n    }\n\n    private set pmUID(v: string) {\n        this.pmUID_ = v;\n        this.axios = this.createAxiosInstance();\n    }\n\n    private get accessToken(): string {\n        return this.accessToken_;\n    }\n\n    private set accessToken(v: string) {\n        this.accessToken_ = v;\n        this.axios = this.createAxiosInstance();\n    }\n\n    private get refreshToken(): string {\n        return this.refreshToken_;\n    }\n\n    private set refreshToken(v: string) {\n        this.refreshToken_ = v;\n    }\n\n    private users_: UsersRoutes;\n    public get users(): UsersRoutes {\n        return this.users_;\n    }\n\n    private keys_: KeysRoutes;\n    public get keys(): KeysRoutes {\n        return this.keys_;\n    }\n\n    private labels_: LabelsRoutes;\n    public get labels(): LabelsRoutes {\n        return this.labels_;\n    }\n\n    private messages_: MessagesRoutes;\n    public get messages(): MessagesRoutes {\n        return this.messages_;\n    }\n\n    private events_: EventsRoutes;\n    public get events(): EventsRoutes {\n        return this.events_;\n    }\n\n    public get isLoggedIn(): boolean {\n        return this.isloggedIn_;\n    }\n\n    constructor(options?: Partial<IProtonmailClientOptions>) {\n        super();\n        this.users_ = new UsersRoutes(this);\n        this.keys_ = new KeysRoutes(this);\n        this.labels_ = new LabelsRoutes(this);\n        this.messages_ = new MessagesRoutes(this);\n        this.events_ = new EventsRoutes(this);\n\n        if (options) {\n            if (typeof options.userAgent === \"string\") {\n                this.options.userAgent = options.userAgent;\n            }\n\n            if (typeof options.domain === \"string\") {\n                this.options.domain = options.domain;\n            }\n\n            if (typeof options.rateLimit === \"boolean\") {\n                this.options.rateLimit = options.rateLimit;\n            }\n        }\n\n        this.axios = this.createAxiosInstance();\n    }\n\n    private createAxiosInstance(): AxiosInstance {\n        const ar: AxiosTransformer[] = [];\n        const transformResponse = ar.concat(\n            axios.defaults.transformResponse!,\n            (data: IBaseAPIResponse) => {\n                return data;\n            }\n        );\n\n        const headers: any = {\n            \"Accept\": \"application/vnd.protonmail.v1+json\",\n            \"User-Agent\": this.options.userAgent,\n            \"x-pm-apiversion\": \"3\",\n            \"x-pm-appversion\": \"Other\",\n        };\n\n        if (typeof window !== \"undefined\") {\n            delete headers[\"User-Agent\"];\n        }\n\n        if (this.pmUID !== \"\") {\n            headers[\"x-pm-uid\"] = this.pmUID;\n        }\n\n        if (this.accessToken !== \"\") {\n            headers.Authorization = `Bearer ${this.accessToken}`;\n        }\n\n        return axios.create({\n            transformResponse,\n            baseURL: `https://${this.options.domain}/api/`,\n            headers,\n            withCredentials: true,\n        });\n    }\n\n    public async request<T>(config: AxiosRequestConfig): Promise<AxiosResponse<T>> {\n        if (this.options.rateLimit) {\n            await this.rateLimiter.wait();\n        }\n\n        while (this.refreshingToken_ && config.url !== \"auth/refresh\") {\n            await wait(100);\n        }\n\n        try {\n            config.timeout = 60 * 1000 * 5;\n            const response = await this.axios.request<T>(config);\n            return response;\n        } catch (error) {\n            try {\n                if (error.response.status === 401 &&\n                    config.url !== \"auth/refresh\" &&\n                    this.refreshToken !== \"\") {\n                    if (!this.refreshingToken_) {\n                        this.refreshingToken_ = true;\n                        await this.loginWithToken({\n                            RefreshToken: this.refreshToken,\n                            Uid: this.pmUID,\n                        });\n                        this.refreshingToken_ = false;\n                    }\n                    return this.request<T>(config);\n                }\n            } catch (error) {\n                if (error.response) {\n                    if (error.response.status >= 400 &&\n                        error.response.status !== 429\n                        && error.response.status < 500) {\n                        this.isloggedIn_ = false;\n                        this.emit(\"logout\");\n                    }\n                }\n                this.refreshingToken_ = false;\n            }\n            throw error;\n        }\n    }\n\n    public async loginWithToken(loginInformation: ITokenLoginInformation) {\n        this.pmUID = loginInformation.Uid;\n        const response = await this.authRefresh(loginInformation.RefreshToken, loginInformation.Uid);\n        this.accessToken = response.AccessToken;\n        this.refreshToken = response.RefreshToken;\n        this.pmUID = response.Uid;\n        this.isloggedIn_ = true;\n        this.emit(\"refresh_token_change\");\n        return response;\n    }\n\n    public async fetchKeys(passwordInformation: IPasswordInformation) {\n        if (!this.isloggedIn_) {\n            throw new Error(\"You must login first\");\n        }\n\n        let key_id: string = \"\", privateKey: string = \"\",  privateKey_: string = \"\",publicKey: string = \"\", token_: string = \"\";\n        const address = await this.keys.address();\n        address.Addresses.forEach(addr => {\n            addr.Keys.forEach(key => {\n                if (key.Primary === 1) {\n                    //key_id = key.ID;\n                    token_ = key.Token;\n                    privateKey_ = key.PrivateKey;\n                    publicKey = key.PublicKey;\n                }\n            });\n        });\n\n\n        const users = await this.keys.users();\n        users.User.Keys.forEach(key => {\n            if (key.Primary === 1) {\n                key_id = key.ID;\n                privateKey = key.PrivateKey;\n            }\n        });\n\n       \n        let key_salt: string = \"\";\n        const salts = await this.keys.keySalts();\n        salts.KeySalts.forEach(salt => {\n            if (salt.ID === key_id) {\n                key_salt = salt.KeySalt;\n            }\n        });\n        \n        //console.log(\"PRIVATE - \", privateKey);\n        //console.log(\"PUBLIC - \", publicKey);\n        //console.log(\"key_id - \",key_id);\n        //console.log(\"key_salt - \",key_salt);\n        \n        const passphrase = await computeKeyPassword(passwordInformation.password, key_salt);\n        //console.log(\"passphrase - \",passphrase);\n        //console.log(\"token_\", token_);\n        const publicKey_1 = await readKey({\n            armoredKey: publicKey,\n        });\n\n        const privateKey_1 = await decryptKey({\n            privateKey: await readPrivateKey({\n                armoredKey: privateKey,\n            }),\n            passphrase: passphrase,\n        });\n\n        const message_1 = await readMessage({\n            armoredMessage: token_,\n        });\n\n        const { data: decrypted_ } = await decrypt({\n            message: message_1,\n            decryptionKeys: privateKey_1,\n            verificationKeys: publicKey_1,\n        });\n        //console.log(decrypted_);\n        \n        this.keysInfo_.privateKey = privateKey_;\n        this.keysInfo_.publicKey = publicKey;\n        this.keysInfo_.passphrase = decrypted_;\n    }\n\n    public async decryptMessage(armoredMessage: IMessage) {\n        const publicKey = await readKey({\n            armoredKey: this.keysInfo_.publicKey,\n        });\n\n        const privateKey = await decryptKey({\n            privateKey: await readPrivateKey({\n                armoredKey: this.keysInfo_.privateKey,\n            }),\n            passphrase: this.keysInfo_.passphrase,\n        });\n\n        const message = await readMessage({\n            armoredMessage: armoredMessage.Body,\n        });\n\n        const { data: decrypted } = await decrypt({\n            message: message,\n            decryptionKeys: privateKey,\n            verificationKeys: publicKey,\n        });\n\n        return decrypted;\n    }\n\n    public getTokenLoginInformation(): ITokenLoginInformation {\n        return {\n            Uid: this.pmUID,\n            RefreshToken: this.refreshToken,\n        };\n    }\n\n    public async login(loginInformation: ILoginInformation) {\n        const username = loginInformation.username.replace(/@.*$/g, \"\");\n        const authInfoResponse = await this.authInfo(username);\n        const req = await getSrp({\n            Version: authInfoResponse.Version,\n            Modulus: authInfoResponse.Modulus,\n            ServerEphemeral: authInfoResponse.ServerEphemeral,\n            Username: username,\n            Salt: authInfoResponse.Salt,\n        }, {\n            password: loginInformation.loginPassword,\n        }, authInfoResponse.Version);\n\n        const authData: IAuthRequest = {\n            ClientProof: req.clientProof,\n            ClientEphemeral: req.clientEphemeral,\n            SRPSession: authInfoResponse.SRPSession,\n            Username: username,\n        };\n\n        const authResponse = await this.auth(authData);\n\n        if (req.expectedServerProof !== authResponse.ServerProof) {\n            throw new Error(\"Unexpected server proof\");\n        }\n\n        // only needed for encrypted access tokens, apparently api doesnt send them anymore\n        // const accessToken = await getAccessToken(authResponse.AccessToken, authResponse.PrivateKey, authResponse.KeySalt, info.mailboxPassword || info.loginPassword);\n\n        const accessToken = authResponse.AccessToken;\n        if (/^-----BEGIN PGP MESSAGE-----/.test(accessToken)) {\n            throw new Error(\"Encrypted access tokens are not supported :^(\");\n        }\n\n        const twoFactorEnabled = authResponse[\"2FA\"].Enabled === 1;\n\n        if (twoFactorEnabled &&\n            authResponse[\"2FA\"].TOTP === 0) {\n            throw new Error(\"Unsupported 2FA type\");\n        }\n\n        if (twoFactorEnabled &&\n            typeof loginInformation.otpToken !== \"string\"\n        ) {\n            throw new Error(\"2FA is enabled on the account so you have to provide a 2FA token\");\n        }\n\n        this.accessToken = accessToken;\n        this.refreshToken = authResponse.RefreshToken;\n        this.pmUID = authResponse.Uid;\n        this.emit(\"refresh_token_change\");\n\n        if (twoFactorEnabled) {\n            await this.auth2FA({\n                TwoFactorCode: `${loginInformation.otpToken}`,\n            });\n        }\n\n        this.isloggedIn_ = true;\n    }\n\n    public async logout(): Promise<{}> {\n        const response = await this.request<{}>({\n            method: \"delete\",\n            url: \"auth\",\n        });\n        this.accessToken = \"\";\n        this.pmUID = \"\";\n        this.refreshToken = \"\";\n        return response.data;\n    }\n\n    private async authInfo(username: string) {\n        const response = await this.axios.post<IAuthInfoResponse>(\"auth/info\", {\n            Username: username,\n        });\n        return response.data;\n    }\n\n    private async auth(obj: IAuthRequest) {\n        const response = await this.axios.post<IAuthResponse>(\"auth\", obj);\n        return response.data;\n    }\n\n    private async auth2FA(obj: IAuth2FARequest) {\n        const response = await this.axios.post<IAuth2FAResponse>(\"auth/2fa\", obj);\n        return response.data;\n    }\n\n    private async authRefresh(refreshToken: string, uid: string) {\n        const response = await this.request<IAuthRefreshResponse>({\n            method: \"post\",\n            url: \"auth/refresh\",\n            data: {\n                GrantType: \"refresh_token\",\n                RedirectURI: \"https://protonmail.com\",\n                RefreshToken: refreshToken,\n                ResponseType: \"token\",\n                State: getRandomString(24),\n                UID: uid,\n            },\n        });\n        return response.data;\n    }\n}\n","import { ProtonmailClient } from \"../index\";\nimport { IAddressResponse, IKeySaltsResponse, IUserObject, IUserResponse } from \"./types\";\n\nexport class KeysRoutes {\n    private client: ProtonmailClient;\n\n    constructor(client: ProtonmailClient) {\n        this.client = client;\n    }\n\n    public async address() {\n        const response = await this.client.request<IAddressResponse>({\n            method: \"get\",\n            url: \"addresses\",\n        });\n        return response.data;\n    }\n\n    public async users() {\n        const response = await this.client.request<IUserResponse>({\n            method: \"get\",\n            url: \"users\",\n        });\n        return response.data;\n    }\n\n    public async keySalts() {\n        const response = await this.client.request<IKeySaltsResponse>({\n            method: \"get\",\n            url: \"keys/salts\",\n        });\n        return response.data;\n    }\n}\n\n","import { ProtonmailClient } from \"../index\";\nimport { ILabelsListArgs, ILabelsListResponse } from \"./types\";\nimport { queryStringStringify } from \"../../helpers/queryStringStringify\";\n\nexport class LabelsRoutes {\n    private client: ProtonmailClient;\n\n    constructor(client: ProtonmailClient) {\n        this.client = client;\n    }\n\n    public async list(args: ILabelsListArgs) {\n        const response = await this.client.request<ILabelsListResponse>({\n            method: \"get\",\n            url: `labels?${queryStringStringify(args)}`,\n        });\n        return response.data;\n    }\n}\n","import { IBaseAPIResponse } from \"../types\";\n\nexport enum DefaultLabels {\n    Inbox = 0,\n    SelfSent = 1,\n    Sent2 = 2,\n    Trash = 3,\n    Spam = 4,\n    All = 5,\n    Archive = 6,\n    Sent = 7,\n    Drafts = 8,\n    Starred = 10,\n}\n\nexport enum LabelType {\n    Label = 1,\n    Folder = 2,\n}\n\nexport interface ILabel {\n    ID: string,\n    Name: string,\n    Color: string,\n    Order: number,\n    Notify: number,\n    Path: string,\n    Type: LabelType,\n    Display: number,\n    Exclusive: number,\n}\n\nexport interface ILabelsListResponse extends IBaseAPIResponse {\n    Labels: ILabel[];\n}\n\nexport interface ILabelsListArgs {\n    Type: LabelType,\n}\n","import { ProtonmailClient } from \"../index\";\nimport { IMessageListArgs, IMessagesListResponse, IMessagesGetResponse, IMessagesCountResponse, IMessagesFlagResponse } from \"./types\";\nimport { queryStringStringify } from \"../../helpers/queryStringStringify\";\nimport { DefaultLabels } from \"../labels/types\";\n\nexport class MessagesRoutes {\n    private client: ProtonmailClient;\n\n    constructor(client: ProtonmailClient) {\n        this.client = client;\n    }\n\n    public async list(args: IMessageListArgs) {\n        const url = `messages?${queryStringStringify(args)}`;\n\n        const response = await this.client.request<IMessagesListResponse>({\n            method: \"get\",\n            url,\n        });\n        return response.data;\n    }\n\n    public async get(id: string) {\n        const response = await this.client.request<IMessagesGetResponse>({\n            method: \"get\",\n            url: `messages/${encodeURIComponent(id)}`,\n        });\n        return response.data;\n    }\n\n    public async count() {\n        const response = await this.client.request<IMessagesCountResponse>({\n            method: \"get\",\n            url: \"messages/count\",\n        });\n        return response.data;\n    }\n\n    public async markAsRead(IDs: string[]) {\n        const response = await this.client.request<IMessagesFlagResponse>({\n            method: \"put\",\n            url: \"messages/read\",\n            data: {\n                IDs,\n            },\n        });\n        return response.data;\n    }\n\n    public async markAsUnread(IDs: string[]) {\n        const response = await this.client.request<IMessagesFlagResponse>({\n            method: \"put\",\n            url: \"messages/unread\",\n            data: {\n                IDs,\n            },\n        });\n        return response.data;\n    }\n\n    public async label(IDs: string[], labelId: DefaultLabels | number | string) {\n        const response = await this.client.request<IMessagesFlagResponse>({\n            method: \"put\",\n            url: \"messages/label\",\n            data: {\n                IDs,\n                LabelID: labelId,\n            },\n        });\n        return response.data;\n    }\n\n    public async unlabel(IDs: string[], labelId: DefaultLabels | number | string) {\n        const response = await this.client.request<IMessagesFlagResponse>({\n            method: \"put\",\n            url: \"messages/label\",\n            data: {\n                IDs,\n                LabelID: labelId,\n            },\n        });\n        return response.data;\n    }\n\n    public async delete(IDs: string[]) {\n        const response = await this.client.request<IMessagesFlagResponse>({\n            method: \"put\",\n            url: \"messages/delete\",\n            data: {\n                IDs,\n                // You can only delete the message from Trash\n                LabelID: DefaultLabels.Trash,\n            },\n        });\n        return response.data;\n    }\n}\n","import { ProtonmailClient } from \"../index\";\nimport { IUsersResponse } from \"./types\";\n\nexport class UsersRoutes {\n    private client: ProtonmailClient;\n\n    constructor(client: ProtonmailClient) {\n        this.client = client;\n    }\n\n    public async me() {\n        const response = await this.client.request<IUsersResponse>({\n            method: \"get\",\n            url: \"users\",\n        });\n        return response.data;\n    }\n}\n","export const VERIFICATION_STATUS = {\n    NOT_SIGNED: 0,\n    SIGNED_AND_VALID: 1,\n    SIGNED_AND_INVALID: 2,\n};\n\nexport const SRP_LEN = 2048;\n\nexport const AUTH_FALLBACK_VERSION = 2;\nexport const AUTH_VERSION = 4;\n\nexport const MAX_VALUE_ITERATIONS = 1000;\n\nexport const SRP_MODULUS_KEY = `-----BEGIN PGP PUBLIC KEY BLOCK-----\n\nxjMEXAHLgxYJKwYBBAHaRw8BAQdAFurWXXwjTemqjD7CXjXVyKf0of7n9Ctm\nL8v9enkzggHNEnByb3RvbkBzcnAubW9kdWx1c8J3BBAWCgApBQJcAcuDBgsJ\nBwgDAgkQNQWFxOlRjyYEFQgKAgMWAgECGQECGwMCHgEAAPGRAP9sauJsW12U\nMnTQUZpsbJb53d0Wv55mZIIiJL2XulpWPQD/V6NglBd96lZKBmInSXX/kXat\nSv+y0io+LR8i2+jV+AbOOARcAcuDEgorBgEEAZdVAQUBAQdAeJHUz1c9+KfE\nkSIgcBRE3WuXC4oj5a2/U3oASExGDW4DAQgHwmEEGBYIABMFAlwBy4MJEDUF\nhcTpUY8mAhsMAAD/XQD8DxNI6E78meodQI+wLsrKLeHn32iLvUqJbVDhfWSU\nWO4BAMcm1u02t4VKw++ttECPt+HUgPUq5pqQWe5Q2cW4TMsE\n=Y4Mw\n-----END PGP PUBLIC KEY BLOCK-----`;\n\n// Version 2 of bcrypt with 2**10 rounds.\n// https://en.wikipedia.org/wiki/Bcrypt#Description\nexport const BCRYPT_PREFIX = \"$2y$10$\";\n","import bcrypt from \"bcryptjs\";\nimport randomBytes from \"randombytes\";\nimport { BCRYPT_PREFIX } from \"./constants\";\n\n/**\n * Compute the key password.\n * @param {String} password plaintext password\n * @param {String} salt base 64 encoded string\n * @returns {Promise<String>}\n */\nexport const computeKeyPassword = async (password: string, salt: string) => {\n    if (!password || !salt || salt.length !== 24 || password.length < 1) {\n        throw new Error(\"Password and salt required.\");\n    }\n    const saltBinary = Buffer.from(salt, \"base64\");\n    const hash = await bcrypt.hash(password, BCRYPT_PREFIX + bcrypt.encodeBase64(saltBinary, 16));\n    // Remove bcrypt prefix and salt (first 29 characters)\n    return hash.slice(29);\n};\n\n/**\n * Generate salt for a key.\n * @returns {String}\n */\nexport const generateKeySalt = () => randomBytes(16).toString(\"base64\");\n","import bcrypt from \"bcryptjs\";\nimport createHash from \"create-hash\";\n\nimport { cleanUsername } from \"./utils/username\";\nimport { BCRYPT_PREFIX } from \"./constants\";\n\nexport const encodeUtf8 = (input: string) => unescape(encodeURIComponent(input));\n\n/**\n * Expand a hash\n * @param {Buffer} input\n * @returns {Promise<Buffer>}\n */\nexport const expandHash = async (input: Buffer) => {\n    const promises = [];\n    const arr = Buffer.concat([input, Buffer.from([0])]);\n    for (let i = 1; i <= 4; i++) {\n        promises.push((createHash(\"sha512\") as any).update(arr).digest());\n        arr[arr.length - 1] = i;\n    }\n    return Buffer.concat(await Promise.all(promises));\n};\n\n/**\n * Format a hash\n * @param {String} password\n * @param {String} salt\n * @param {Buffer} modulus\n * @returns {Promise<Buffer>}\n */\nconst formatHash = async (password: string, salt: string, modulus: Buffer) => {\n    const unexpandedHash = await bcrypt.hash(password, BCRYPT_PREFIX + salt);\n    return expandHash(Buffer.concat([Buffer.from(unexpandedHash), modulus]));\n};\n\n/**\n * Hash password in version 3.\n * @param {String} password\n * @param {String} salt\n * @param {Buffer} modulus\n * @returns {Promise<Buffer>}\n */\nconst hashPassword3 = (password: string, salt: string, modulus: Buffer) => {\n    const saltBinary = Buffer.from(salt + \"proton\", \"binary\");\n    return formatHash(password, bcrypt.encodeBase64(saltBinary, 16), modulus);\n};\n\n/**\n * Hash password in version 1.\n * @param {String} password\n * @param {String} username\n * @param {Buffer} modulus\n * @returns {Promise<Buffer>}\n */\nconst hashPassword1 = async (password: string, username: string, modulus: Buffer) => {\n    const value = Buffer.from(encodeUtf8(username.toLowerCase()));\n    const salt = (createHash(\"md5\") as any).update(value).digest(\"hex\");\n    return formatHash(password, salt, modulus);\n};\n\n/**\n * Hash password in version 0.\n * @param {String} password\n * @param {String} username\n * @param {Buffer} modulus\n * @returns {Promise<Buffer>}\n */\nconst hashPassword0 = async (password: string, username: string, modulus: Buffer) => {\n    const prehashed = (createHash(\"sha512\") as any).update(Buffer.from(username.toLowerCase() + encodeUtf8(password))).digest(\"base64\");\n    return hashPassword1(prehashed, username, modulus);\n};\n\n/**\n * Hash a password.\n * @param {String} password\n * @param {String} salt\n * @param {String} username\n * @param {Buffer} modulus\n * @param {Number} version\n * @returns {Promise<Buffer>}\n */\nexport const hashPassword = ({ password, salt, username, modulus, version }: { password: string, salt: string | undefined, username: string | undefined, modulus: Buffer, version: number }) => {\n    if (version === 4 || version === 3) {\n        return hashPassword3(password, salt as string, modulus);\n    }\n\n    if (version === 2) {\n        return hashPassword1(password, cleanUsername(username), modulus);\n    }\n\n    if (version === 1) {\n        return hashPassword1(password, username as string, modulus);\n    }\n\n    if (version === 0) {\n        return hashPassword0(password, username as string, modulus);\n    }\n\n    throw new Error(\"Unsupported auth version\");\n};\n","import BigNumber from \"bignumber.js\";\nimport randomBytes from \"randombytes\";\nimport { expandHash, hashPassword } from \"./passwords\";\nimport { toBN, fromBN } from \"./utils/bigNumber\";\nimport { SRP_LEN, MAX_VALUE_ITERATIONS } from \"./constants\";\nimport { getModulusWithoutVerification } from \"./utils/modulusWorkaround\";\n\nconst getRandomValues = (buf: Buffer) => randomBytes(buf.length);\n\nconst ZERO_BN = new BigNumber(0);\nconst ONE_BN = new BigNumber(1);\nconst TWO_BN = new BigNumber(2);\n\n/**\n * @param {Buffer} arr\n * @return {Promise<Buffer>}\n */\nexport const srpHasher = (arr: Buffer) => expandHash(arr);\n\n/**\n * Generate a random client secret.\n * @param {Number} len\n * @return {BigNumber}\n */\nconst generateClientSecret = (len: number) => toBN(getRandomValues(Buffer.alloc(len / 8)));\n\n/**\n * Get the client secret. Loops until it finds a safe value.\n * @param {Number} len\n * @return {BigNumber}\n */\nconst getClientSecret = (len: number) => {\n    const comparator = new BigNumber(len * 2);\n\n    for (let i = 0; i < MAX_VALUE_ITERATIONS; ++i) {\n        const clientSecret = generateClientSecret(len);\n\n        if (clientSecret.isLessThanOrEqualTo(comparator)) {\n            continue;\n        }\n\n        return clientSecret;\n    }\n\n    throw new Error(\"Could not find safe client value\");\n};\n\n/**\n * Generate parameters.\n * @param {Object} params\n * @param {Number} params.len\n * @param {BigNumber} params.generator\n * @param {Modulus} params.modulus\n * @param {Buffer} params.serverEphemeralArray\n * @return {Promise<{clientSecret, clientEphemeral, scramblingParam}>}\n */\nconst generateParameters = async ({ len, generator, modulus, serverEphemeralArray }: { len: number, generator: BigNumber, modulus: BigNumber, serverEphemeralArray: Buffer }) => {\n    const clientSecret = getClientSecret(len);\n    const clientEphemeral = generator.exponentiatedBy(clientSecret, modulus);\n    const clientEphemeralArray = fromBN(len, clientEphemeral);\n\n    const clientServerHash = await srpHasher(Buffer.concat([clientEphemeralArray, serverEphemeralArray]));\n    const scramblingParam = toBN(clientServerHash);\n\n    return {\n        clientSecret,\n        clientEphemeral,\n        scramblingParam,\n    };\n};\n\n/**\n * Get parameters. Loops until it finds safe values.\n * @param {Number} len\n * @param {BigNumber} generator\n * @param {Modulus} modulus\n * @param {Buffer} serverEphemeralArray\n * @return {Promise<{clientSecret, clientEphemeral, scramblingParam}>}\n */\nconst getParameters = async ({ len, generator, modulus, serverEphemeralArray }: { len: number, generator: BigNumber, modulus: BigNumber, serverEphemeralArray: Buffer }) => {\n    for (let i = 0; i < MAX_VALUE_ITERATIONS; ++i) {\n        const { clientSecret, clientEphemeral, scramblingParam } = await generateParameters({\n            len,\n            generator,\n            modulus,\n            serverEphemeralArray,\n        });\n\n        if (scramblingParam.isEqualTo(ZERO_BN)) {\n            continue;\n        }\n\n        return {\n            clientSecret,\n            clientEphemeral,\n            scramblingParam,\n        };\n    }\n    throw new Error(\"Could not find safe parameters\");\n};\n\n/**\n * @param {Object} params\n * @param {Number} params.len - Size of the proof (bytes length)\n * @param {Buffer} params.modulusArray\n * @param {Buffer} params.hashedPasswordArray\n * @param {Buffer} params.serverEphemeralArray\n * @return {Promise}\n */\nexport const generateProofs = async ({ len, modulusArray, hashedPasswordArray, serverEphemeralArray }: { len: number, modulusArray: Buffer, hashedPasswordArray: Buffer, serverEphemeralArray: Buffer }) => {\n    const modulusBn = toBN(modulusArray);\n    /*if (modulusBn.bitLength !== len) {\n        throw new Error('SRP modulus has incorrect size');\n    }*/\n\n    const generator = TWO_BN;\n\n    const hashedArray = await srpHasher(Buffer.concat([fromBN(len, generator), modulusArray]));\n\n    const multiplierBn = toBN(hashedArray);\n    const serverEphemeral = toBN(serverEphemeralArray);\n    const hashedPassword = toBN(hashedPasswordArray);\n\n\n    const modulus = new BigNumber(modulusBn);\n    const modulusMinusOne = modulus.minus(ONE_BN);\n    const multiplierReduced = multiplierBn.mod(modulus);\n\n    if (multiplierReduced.isLessThanOrEqualTo(ONE_BN) || multiplierReduced.isGreaterThanOrEqualTo(modulusMinusOne)) {\n        throw new Error(\"SRP multiplier is out of bounds\");\n    }\n\n    if (generator.isLessThanOrEqualTo(ONE_BN) || generator.isGreaterThanOrEqualTo(modulusMinusOne)) {\n        throw new Error(\"SRP generator is out of bounds\");\n    }\n\n    if (serverEphemeral.isLessThanOrEqualTo(ONE_BN) || serverEphemeral.isGreaterThanOrEqualTo(modulusMinusOne)) {\n        throw new Error(\"SRP server ephemeral is out of bounds\");\n    }\n\n    const { clientSecret, clientEphemeral, scramblingParam } = await getParameters({\n        len,\n        generator,\n        modulus,\n        serverEphemeralArray,\n    });\n\n    let subtracted = serverEphemeral.minus(\n        generator.exponentiatedBy(hashedPassword, modulus).multipliedBy(multiplierReduced).mod(modulus)\n    );\n\n    if (subtracted.isLessThan(ZERO_BN)) {\n        subtracted = subtracted.plus(modulus);\n    }\n\n    const exponent = scramblingParam\n        .multipliedBy(hashedPassword)\n        .plus(clientSecret)\n        .modulo(modulus.minus(ONE_BN));\n\n    const sharedSession = subtracted.exponentiatedBy(exponent, modulus);\n\n    const clientEphemeralArray = fromBN(len, clientEphemeral);\n    const sharedSessionArray = fromBN(len, sharedSession);\n\n    const clientProof = await srpHasher(\n        Buffer.concat([clientEphemeralArray, serverEphemeralArray, sharedSessionArray])\n    );\n    const expectedServerProof = await srpHasher(\n        Buffer.concat([clientEphemeralArray, clientProof, sharedSessionArray])\n    );\n\n    return {\n        clientEphemeral: clientEphemeralArray,\n        clientProof,\n        expectedServerProof,\n        sharedSession: sharedSessionArray,\n    };\n};\n\n/**\n * @param {Object} data - Auth info from the API\n * @param {String} data.Modulus - Base 64 encoded server modulus as a pgp signed message\n * @param {Number} data.Version - The auth version\n * @param {String} data.ServerEphemeral - Base64 encoded server ephemeral\n * @param {String} [data.Username] - The user name\n * @param {String} [data.Salt] - Base64 encoded salt\n * @param {Object} credentials - Credentials entered by the user\n * @param {String} [credentials.username] - Username entered\n * @param {String} credentials.password - Password entered\n * @param {Number} [authVersion] - The auth version\n * @return {Promise}\n */\nexport const getSrp = async (\n    { Version, Modulus: serverModulus, ServerEphemeral, Username, Salt }: { Version: number, Modulus: string, ServerEphemeral: string, Username: string, Salt: string },\n    { password }: { password: string },\n    authVersion = Version\n) => {\n    const modulusArray = await getModulusWithoutVerification(serverModulus);\n\n    const serverEphemeralArray = Buffer.from(ServerEphemeral, \"base64\");\n\n    const hashedPasswordArray = await hashPassword({\n        version: authVersion,\n        password,\n        salt: authVersion < 3 ? undefined : Buffer.from(Salt, \"base64\").toString(\"binary\"),\n        username: authVersion < 3 ? Username : undefined,\n        modulus: modulusArray,\n    });\n\n    const { clientEphemeral, clientProof, expectedServerProof, sharedSession } = await generateProofs({\n        len: SRP_LEN,\n        modulusArray,\n        hashedPasswordArray,\n        serverEphemeralArray,\n    });\n\n    return {\n        clientEphemeral: clientEphemeral.toString(\"base64\"),\n        clientProof: clientProof.toString(\"base64\"),\n        expectedServerProof: expectedServerProof.toString(\"base64\"),\n        sharedSession,\n    };\n};\n","import BigNumber from \"bignumber.js\";\n\n/**\n * From Buffer to big number\n * @param {Buffer} arr\n * @return {BigNumber}\n */\nexport const toBN = (arr: Buffer) => {\n    const reversed = Buffer.alloc(arr.length);\n    for (let i = 0; i < arr.length; i++) {\n        reversed[arr.length - i - 1] = arr[i];\n    }\n    return new BigNumber(reversed.toString(\"hex\"), 16);\n};\n\n/**\n * From big number to Buffer\n * @param {Number} len\n * @param {BigNumber} bn\n * @return {Buffer}\n */\nexport const fromBN = (len: number, bn: BigNumber) => {\n    let str = bn.toString(16);\n    if (str.length % 2 !== 0) {\n        str = `0${str}`;\n    }\n    const arr = Buffer.from(str, \"hex\");\n    const reversed = new Buffer(len / 8);\n    for (let i = 0; i < arr.length; i++) {\n        reversed[arr.length - i - 1] = arr[i];\n    }\n\n    return reversed;\n};\n","/**\n * Extract modulus without verification\n * @param {String} modulus - Armored modulus string\n * @returns {Promise<Uint8Array>}\n */\nexport const getModulusWithoutVerification = async (modulus: string) => {\n    const base64Modulus = modulus.split(\"\\n\").find((l) => l.length > 60);\n    if (base64Modulus === undefined) {\n        throw new Error(`could not extract modulus from ${modulus}`);\n    }\n    return Buffer.from(base64Modulus, \"base64\");\n};\n","/**\n * Clean the username, remove underscore, dashes, dots and lowercase.\n * @param {String} name\n * @returns {string}\n */\nexport const cleanUsername = (name = \"\") => name.replace(/[.\\-_]/g, \"\").toLowerCase();\n","module.exports = require(\"axios\");;","module.exports = require(\"bcryptjs\");;","module.exports = require(\"bignumber.js\");;","module.exports = require(\"create-hash\");;","module.exports = require(\"events\");;","module.exports = require(\"openpgp\");;","module.exports = require(\"randombytes\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(620);\n"],"sourceRoot":""}